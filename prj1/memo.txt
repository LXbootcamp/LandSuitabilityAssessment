좌표 데이터를 JSP로 보내기 위해 `DrawVector`의 좌표를 캡처하고 AJAX를 통해 JSP 파일로 전송하는 코드를 추가할 수 있습니다. 먼저, `main.js` 파일에서 좌표를 캡처하고 이를 서버로 전송하는 기능을 구현하겠습니다.

### 1. DrawVector 좌표 캡처
`DrawVector`의 좌표를 캡처하기 위해 `drawend` 이벤트 리스너를 사용합니다. 이 리스너에서 좌표를 추출하고 AJAX 요청을 통해 JSP 파일로 전송합니다.

### 2. AJAX 요청 추가
AJAX 요청을 사용하여 좌표 데이터를 서버로 전송합니다.

### main.js

```javascript
// DrawVector 좌표를 서버로 전송하는 함수 추가
function sendCoordinatesToServer(coordinates) {
  $.ajax({
    url: 'saveCoordinates.jsp', // 서버의 JSP 파일 경로
    type: 'POST',
    data: JSON.stringify({ coordinates: coordinates }),
    contentType: 'application/json; charset=utf-8',
    success: function(response) {
      console.log('Coordinates sent successfully:', response);
    },
    error: function(error) {
      console.error('Error sending coordinates:', error);
    }
  });
}

draw.on("drawend", function (e) {
  DrawSource.clear();
  SelectionsSource.clear();
  const extent = e.feature.getGeometry().getExtent();
  const geomA = e.feature.getGeometry();
  
  // 좌표 데이터를 추출합니다.
  const coordinates = geomA.getCoordinates();
  sendCoordinatesToServer(coordinates);

  vectorSource.forEachFeatureInExtent(extent, function (aa) {
    if (polyIntersectsPoly(geomA, aa.getGeometry()) === true) {
      SelectionsSource.addFeature(aa);
      selectedFeatures.push(aa);
    }
  });
});
```

### saveCoordinates.jsp

`saveCoordinates.jsp` 파일은 클라이언트로부터 받은 좌표 데이터를 처리합니다. 이 파일은 좌표 데이터를 받아서 콘솔에 출력하거나, 필요에 따라 데이터베이스에 저장할 수 있습니다.

```jsp
<%@ page language="java" contentType="application/json; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ page import="java.io.*, javax.servlet.*, javax.servlet.http.*" %>
<%
  StringBuilder jb = new StringBuilder();
  String line = null;
  try {
    BufferedReader reader = request.getReader();
    while ((line = reader.readLine()) != null)
      jb.append(line);
  } catch (Exception e) { 
    e.printStackTrace();
  }

  String jsonData = jb.toString();
  // JSON 데이터를 파싱합니다.
  JSONObject jsonObject = new JSONObject(jsonData);
  JSONArray coordinates = jsonObject.getJSONArray("coordinates");

  // 좌표 데이터를 처리합니다.
  for (int i = 0; i < coordinates.length(); i++) {
    JSONArray coordinate = coordinates.getJSONArray(i);
    System.out.println("Coordinate " + i + ": " + coordinate);
  }

  // 클라이언트에 응답을 보냅니다.
  response.setContentType("application/json");
  response.setCharacterEncoding("UTF-8");
  response.getWriter().write("{\"status\":\"success\"}");
%>
```

위의 코드를 통해 `DrawVector`의 좌표를 JSP 파일로 전송하고, 서버에서 이를 처리할 수 있습니다. 필요에 따라 좌표 데이터를 데이터베이스에 저장하거나, 다른 형태로 처리할 수 있습니다.


var url =
      `./deleteData.jsp?selected_pnu=${encodeURIComponent(click_F_pnu)}`;
    fetch(url, {
      method: "POST",
    })
      .then((response) => response.text())
      .then((data) => {
        console.log("Response from server:", data);
    
      })
      .catch((error) => {
        console.error("Error:", error);
      });


          // 팝업 표시
    const selectedFeature = vectorSource
      .getFeatures()
      .find((feature) => feature.get("jibun") === click_F_Jibun);
    if (selectedFeature) {
      document.getElementById("info-title").innerHTML = click_F_Jibun;
      document.getElementById("info01").innerHTML =
        "지목: " + click_F_lndcgr_code_nm;
      document.getElementById("info02").innerHTML =
        "면적: " + click_F_lndpcl_ar + "㎡";
      document.getElementById("info03").innerHTML =
        "용도지역: " + click_F_prpos_area_1_nm;
      document.getElementById("info04").innerHTML =
        "토지형태: " + click_F_tpgrph_frm_code;
      document.getElementById("info05").innerHTML =
        "도로인접면: " + click_F_road_side_code_nm;

      if (centers2[emdid]) {
        const selectedCenter = centers2[emdid];
        overlay.setPosition(selectedCenter);
      } else {
        console.log("Selected center not found in centers object");
      }
    }













    // try{
    // // JDBC 읽어오기
	// Class.forName("org.postgresql.Driver");
	// // DBMS와 연결
	// con = DriverManager.getConnection(url, user, pwd);
	// // 쿼리 준비
	// stmt = con.createStatement();

    // String query = "insert into polygon_data (area, round, develop_value, conserve_value, compre_value) values ('"+ developValue +"', '"+ conserveValue +"', '"+ compreValue +"');";
    // out.println("<br><br>query = " + query + "<br><br>");
    // int rs = stmt.executyUpdate(query);

    // if (index.equals("1")) {
    //     // insert 쿼리문
    //     String query = "insert into polygon_data (develop_value, conserve_value, compre_value, geom) values ('"+ developValue +"', '"+ conserveValue +"', '"+ compreValue +"', '"+ geom+"');";
    //     out.println("<br><br>query = " + query + "<br><br>");
    //     int rs = stmt.executyUpdate(query);
    // } else if (index.equals("2")) {
    //     // update 쿼리문
    //     String query = "update polygon_data set develop_value = '"+ developValue +"', conserve_value = '"+ conserveValue +"', compre_value = '"+ compreValue +"' where geom = '"+ geom +"';";
    //     out.println("<br><br>query = " + query + "<br><br>");
    //     int rs = stmt.executyUpdate(query);
    // } else if (index.equals("3")) {
    //     // delete 쿼리문
    //     String query = "delete from polygon_data where geom = '"+ geom +"';";
    //     out.println("<br><br>query = " + query + "<br><br>");
    //     int rs = stmt.executyUpdate(query);
    // }
    // if (pstmt != null) {
    //     int result = stmt.executeUpdate();
    //     out.println("Query executed successfully. Affected rows: " + result);
    // }
// }catch (Exception e) {
//     e.printStackTrace(out);
// } finally {
//     try {
//         if (pstmt != null) pstmt.close();
//         if (con != null) con.close();
//     } catch (SQLException e) {
//         e.printStackTrace(out);
//     }
// }